#
# Top level, common rules
#

# set install directory
DESTDIR=/usr/local

# choose your favorite compiler
CC=gcc

# Uncomment this to turn debugging on
# DEBUG:=1

#
# compile/link flags. Always use += to set variables here!
#
ifdef DEBUG
 CFLAGS+=-g -DINLINE=static -pipe
 LDFLAGS+=-g
else
 CFLAGS+=-O2 -fomit-frame-pointer -DINLINE="extern inline" -pipe
 LDFLAGS+=-s
endif

#
# how picky should your compiler be? uncomment for paranoid gcc settings.
# PARANOID_GCC:=1

#
# apply known-good GCC compiler flags.
#
ifeq ($(CC),gcc)
  CFLAGS+=-Wall -Wshadow -Wno-uninitialized
  ifdef PARANOID_GCC
    CFLAGS+=-Wstrict-prototypes -Wcast-qual -Wcast-align -Wpointer-arith -Wbad-function-cast -Waggregate-return -Winline
  endif
endif


#
# set `ar' archiver...
#
AR=ar

#
# `cp -f' : `cp' with force overwrite
#
CP=cp -f

#
# `ln -sf' : `ln' with soft links, force overwrite
#
LN=ln -sf

#
# `mkdir -p' or `mkdirhier' : make a directory and all missing directory parents
#
MKDIR=mkdir -p
#MKDIR=mkdirhier


#
# a variation of `echo' that interprets \n as newline
#
ECHO=echo -e
#ECHO=echo


#
# --------------- no user-serviceable parts below this line ----------------
#

TW_VERSION=0.3.5

CFLAGS+=-I$(TOPDIR)/include

MODFLAGS+=-DMODULE

CONF:=$(TOPDIR)/conf/config.status

LIBTW:=-L$(TOPDIR)/lib -lTw
ifeq ($(CONF__SHLIBS),n)
  ifeq ($(CONF_SOCKET_GZ),y)
    LIBTW+=-lz
  endif
endif

BASH:=$(shell if [ -x /bin/bash ]; then echo /bin/bash; \
       else if bash -c : 2>/dev/null; then echo bash; \
       else if [ -x "$$BASH" ]; then echo $$BASH; \
       else echo sh; fi; fi; fi)

BASH_VERSION:=$(word 1,$(subst ., ,$(shell $(BASH) -c "echo \$$BASH_VERSION")))

config $(CONF):
	@echo Starting configure for twin $(TW_VERSION) ... ; \
	echo
	cd $(TOPDIR) ; \
	$(BASH) scripts/Configure

menuconf menuconfig:
	@echo Starting menu-dialog configure for twin $(TW_VERSION) ... ; \
	echo
	cd $(TOPDIR) ; \
	$(BASH) scripts/Configure.dialog

reconfig: config all


nullconfig:
	cd $(TOPDIR) ; \
	$(BASH) scripts/Configure < /dev/null > /dev/null

# collect together in $(OBJS) all objs from $(BINS) looking in $(OBJS_xxx)
OBJS:=$(foreach B,$(BINS),$(OBJS_$(B)))

# same with $(MODOBJS) from $(MODBINS)
MODOBJS:=$(foreach B,$(MODBINS),$(OBJS_$(B)))

# same with $(ARLIBOBJS) from $(ARLIBS)
ARLIBOBJS:=$(foreach B,$(ARLIBS),$(OBJS_$(B)))

# set correct CFLAGS for objs compiled as modules
ifneq ($(MODOBJS),)
  _ALLFLAGS:=$(strip $(patsubst %,CFLAGS_%+=$(MODFLAGS)\n,$(MODOBJS)))
endif

_ALLBINS:=$(strip $(BINS) $(MODBINS) $(ARLIBS))

_ALLOBJS:=$(strip $(OBJS) $(MODOBJS) $(ARLIBOBJS) $(EXCL_OBJS))

_ALLSRCS:=$(strip $(subst .o,.c,$(filter %.o,$(_ALLOBJS))))

.modules: Makefile $(TOPDIR)/MakeRules $(CONF)
	@$(ECHO) -n Building .modules... ; \
	 $(ECHO) " $(_ALLFLAGS)" > .modules ; \
	 $(ECHO) " $(foreach B,$(BINS) $(MODBINS),$(B): .$(B).link\n .$(B).link: $(OBJS_$(B))\n)" >> .modules ; \
	 $(ECHO) " $(foreach B,$(ARLIBS),$(B): .$(B).arlib\n .$(B).arlib: $(OBJS_$(B))\n)" >> .modules ; \
	 $(ECHO) done

.depend: Makefile $(TOPDIR)/MakeRules $(TOPDIR)/scripts/MkDep $(_ALLSRCS)
	$(BASH) $(TOPDIR)/scripts/MkDep $(TOPDIR) $(filter -I%,$(CFLAGS)) -- $(_ALLSRCS) > .depend

$(TOPDIR)/scripts/MkDep:
	$(LN) MkDep$(BASH_VERSION) $(TOPDIR)/scripts/MkDep


%.dir:
	$(MAKE) -C $*

%.o: %.c
	$(CC) $(CFLAGS) $(CFLAGS_$@) -c $< -o $@
	@$(ECHO) ' ifeq ($$(strip $$(CC) $$(CFLAGS) $$(CFLAGS_$@)),$(strip $(CC) $(CFLAGS) $(CFLAGS_$@)))\n'\
	'FILES_UP_TO_DATE += $@\n'\
	'endif' > .$@.flags

# this would be:
# % : $(OBJS_%)
#	$(CC) -o $* $(OBJS_$*) $(LDFLAGS) $(LDFLAGS_$*)
#	...
# but 1) nasty match-all rules like this are a real pain
# and 2) $(OBJS_%) doesn't expand
# so we put into .modules an explicited version of what follows:
# % : .%.link
# .%.link : $(OBJS_%)
#
# and we keep implicit the last step:
#
.%.link:
	$(CC) -o $* $(OBJS_$*) $(LDFLAGS) $(LDFLAGS_$*)
	@$(LN) $* $@ ; \
	 $(ECHO) ' ifeq ($$(strip $$(CC) $$(OBJS_$*) $$(LDFLAGS) $$(LDFLAGS_$*)),$(strip $(CC) $(OBJS_$*) $(LDFLAGS) $(LDFLAGS_$*)))\n'\
	 'FILES_UP_TO_DATE += $@\n'\
	 'endif' > $@.flags

#
# same with `ar' archives
#
.%.arlib:
	rm -f $* && $(AR) cr $* $(OBJS_$*)
	@$(LN) $* $@ ; \
	 $(ECHO) ' ifeq ($$(strip $$(ARLIB) $$(OBJS_$*)),$(strip $(ARLIB) $(OBJS_$*)))\n'\
	 'FILES_UP_TO_DATE += $@\n'\
	 'endif' > $@.flags


# forbid GNU-make to `rm -f $(OBJS) $(MODOBJS) $(ARLIBOBJS)' after build
.SECONDARY: $(OBJS) $(MODOBJS) $(ARLIBOBJS)


#
# Find files whose flags have changed and force recompilation.
# For safety, this works in the converse direction:
#   every file is forced, except those whose flags are positively up-to-date.
#
# to avoid useless re-making, we never force files in other directories:
# `make' must already visit all directories anyway.
#
FILES := $(OBJS) $(MODOBJS) $(ARLIBOBJS) \
	 $(patsubst %,.%.link,$(BINS) $(MODBINS)) \
	 $(patsubst %,.%.arlib,$(ARLIBS))

FILES_UP_TO_DATE := $(filter-out $(wildcard * .*), $(FILES))


FILES_FLAGS_EXIST := $(wildcard .*.flags)
ifneq ($(FILES_FLAGS_EXIST),)
 include $(FILES_FLAGS_EXIST)
endif

FILES_CHANGED := $(strip $(filter-out $(FILES_UP_TO_DATE), $(FILES)))


ifneq ($(FILES_CHANGED),)

# be _very_ brutal...
# $(shell rm -f $(FILES_CHANGED))

# ..or be more kind

dummy:
	@:

$(FILES_CHANGED): dummy

endif

