



/* This file was automatically generated with m4 from m4/libTwmacros.m4, do not edit! */

#if TW_CAN_UNALIGNED != 0
typedef struct s_reply *reply;
struct s_reply {
    uldat Len, Serial, Code, Data;
};
# define MyLen  MyReply->Len
# define MyCode MyReply->Code
# define MyData (&MyReply->Data)
# define DECL_MyReply reply MyReply;
# define INIT_MyReply 
#else
# define DECL_MyReply byte *MyReply, *MyData; uldat MyLen, MyCode;
# define INIT_MyReply (Pop(MyReply,uldat,MyLen), /*skip Serial:*/ Pop(MyReply,uldat,MyCode), Pop(MyReply,uldat,MyCode), MyData=MyReply, MyReply-=3*sizeof(uldat)),
#endif





















































































/*
 *  sockproto.m4 --  macroized prototypes for libTw functions.
 *                   used as template for a lot of autogenerated files.
 *
 *                   the prototypes are used both on client and server side
 *                   to implement function calls <-> socket data stream
 *                   conversion.
 *                   You can also see this as a custom version of
 *                   remote procedure calling.
 *
 *  Copyright (C) 1999-2001 by Massimiliano Ghilardi
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 */

/*

 format of this file: each non-empty line is of the form
 
 PROTO(<rettype>,<retflag>, <action>,<object>,<self>, <arg1type>,<arg1flag>, ...)

 the number of arguments the function wants must be deduced
 from the number of formal args in each PROTO(...) definition.

 <flag> : v = void
	  _ = scalar (any integer)
	  x = pointer
	  V(len) = vector of <len> elements
		<len> can be an expression, and may access the other arguments
		of the function as an where <n> is the progressive number
		of the argument: a1 is the first arg, a2 the second, ...
	  W(len) = vector of <len> elements, with double-checking/autodetect on len
		so that you can safely pass NULL instead of the vector.

 Function calls wait until server has processed the command and returned the result
 if their return value is not void.
 
 <action> : the function name (Create, Map, Delete, ...)
 <object> : the object it acts upon (Gadget, Window, ...)
 
 <self> : 0 if the server implementation does not need the Fn##object method pointer
	: 1 if the function in the server needs the Fn##object method pointer
	: 2 if the Fn##object method pointer is extracted from the first argument
	

*/

#define OK_MAGIC	((uldat)0x3E4B4F3Cul)
#define FAIL_MAGIC	((uldat)0xFFFFFFFFul)

#define FIND_MAGIC		((uldat)0x646E6946ul) /* i.e. "Find" */
#define MSG_MAGIC		((uldat)0x2167734dul) /* i.e. "Msg!" */

static uldat _Tw_FindFunction(tw_d TwD, byte a1, TW_CONST byte *a2, byte a3, TW_CONST byte *a4) {
    uldat a0;
    DECL_MyReply
    uldat len2;
    uldat len4;
    /* exception: Tw_FindFunction_() must be called WITH LOCK HELD! */
    uldat My;
    if (Fd != TW_NOFD) {
	id_Tw[order_FindFunction] = FIND_MAGIC;
	if (InitRS(TwD)) {
	    My = (0 + sizeof(byte) + (len2 = (a1) * sizeof(byte)) + sizeof(byte) + (len4 = (a3) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,byte,a1); PushV(s,len2,a2); Push(s,byte,a3); PushV(s,len4,a4); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FindFunction]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(uldat ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(uldat  *)MyData;
#else
			    Pop(MyData, uldat , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FindFunction);
			    a0 = (uldat )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FindFunction);
			a0 = (uldat )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    }
    return (uldat)0;
}

static byte _Tw_SyncSocket(tw_d TwD) {
    byte a0;
    DECL_MyReply
    uldat My;
    if (Fd != TW_NOFD && ((My = id_Tw[order_SyncSocket]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_SyncSocket)) != TW_NOID)) {
	if (InitRS(TwD)) {
            
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_SyncSocket]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(byte ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(byte  *)MyData;
#else
			    Pop(MyData, byte , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_SyncSocket);
			    a0 = (byte )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_SyncSocket);
			a0 = (byte )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    return a0;
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_SyncSocket);
    
    return (byte)0;
}

byte Tw_ServerSizeof(tw_d TwD, byte a1) {
    byte a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_ServerSizeof]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_ServerSizeof)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(byte) );
            if (WQLeft(My)) {
                Push(s,byte,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_ServerSizeof]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(byte ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(byte  *)MyData;
#else
			    Pop(MyData, byte , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_ServerSizeof);
			    a0 = (byte )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_ServerSizeof);
			a0 = (byte )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_ServerSizeof);
    
    UNLK;
    return (byte)0;
}

byte Tw_CanCompress(tw_d TwD) {
    byte a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_CanCompress]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_CanCompress)) != TW_NOID)) {
	if (InitRS(TwD)) {
            
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_CanCompress]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(byte ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(byte  *)MyData;
#else
			    Pop(MyData, byte , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_CanCompress);
			    a0 = (byte )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_CanCompress);
			a0 = (byte )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_CanCompress);
    
    UNLK;
    return (byte)0;
}
byte Tw_DoCompress(tw_d TwD, byte a1) {
    byte a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_DoCompress]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_DoCompress)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(byte) );
            if (WQLeft(My)) {
                Push(s,byte,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_DoCompress]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(byte ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(byte  *)MyData;
#else
			    Pop(MyData, byte , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_DoCompress);
			    a0 = (byte )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_DoCompress);
			a0 = (byte )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_DoCompress);
    
    UNLK;
    return (byte)0;
}

void Tw_NeedResizeDisplay(tw_d TwD) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_NeedResizeDisplay]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_NeedResizeDisplay)) != TW_NOID)) {
	if (InitRS(TwD)) {
            
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_NeedResizeDisplay]);
                    UNLK;return;
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_NeedResizeDisplay);
    
    UNLK;
}

void Tw_AttachHW(tw_d TwD, uldat a1, TW_CONST byte *a2, byte a3) {
    
    uldat len2;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_AttachHW]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_AttachHW)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + (len2 = (a1) * sizeof(byte)) + sizeof(byte) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); PushV(s,len2,a2); Push(s,byte,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_AttachHW]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_AttachHW);
    
    UNLK;
}
byte Tw_DetachHW(tw_d TwD, uldat a1, TW_CONST byte *a2) {
    byte a0;
    DECL_MyReply
    uldat len2;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_DetachHW]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_DetachHW)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + (len2 = (a1) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); PushV(s,len2,a2); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_DetachHW]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(byte ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(byte  *)MyData;
#else
			    Pop(MyData, byte , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_DetachHW);
			    a0 = (byte )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_DetachHW);
			a0 = (byte )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_DetachHW);
    
    UNLK;
    return (byte)0;
}

void Tw_SetFontTranslation(tw_d TwD, TW_CONST byte *a1) {
    
    uldat len1;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_SetFontTranslation]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_SetFontTranslation)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + (len1 = (0x80) * sizeof(byte)) );
            if (WQLeft(My)) {
                PushV(s,len1,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_SetFontTranslation]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_SetFontTranslation);
    
    UNLK;
}

void Tw_DeleteObj(tw_d TwD, tobj a1) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_DeleteObj]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_DeleteObj)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_DeleteObj]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_DeleteObj);
    
    UNLK;
}
void Tw_ChangeFieldObj(tw_d TwD, tobj a1, udat a2, uldat a3, uldat a4) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_ChangeFieldObj]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_ChangeFieldObj)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(udat) + sizeof(uldat) + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,udat,a2); Push(s,uldat,a3); Push(s,uldat,a4); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_ChangeFieldObj]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_ChangeFieldObj);
    
    UNLK;
}

twidget Tw_CreateWidget(tw_d TwD, dat a1, dat a2, uldat a3, uldat a4, dat a5, dat a6, hwattr a7) {
    twidget a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_CreateWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_CreateWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(dat) + sizeof(dat) + sizeof(uldat) + sizeof(uldat) + sizeof(dat) + sizeof(dat) + sizeof(hwattr) );
            if (WQLeft(My)) {
                Push(s,dat,a1); Push(s,dat,a2); Push(s,uldat,a3); Push(s,uldat,a4); Push(s,dat,a5); Push(s,dat,a6); Push(s,hwattr,a7); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_CreateWidget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(twidget ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(twidget  *)MyData;
#else
			    Pop(MyData, twidget , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_CreateWidget);
			    a0 = (twidget )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_CreateWidget);
			a0 = (twidget )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_CreateWidget);
    
    UNLK;
    return TW_NOID;
}
void Tw_RecursiveDeleteWidget(tw_d TwD, twidget a1) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_RecursiveDeleteWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_RecursiveDeleteWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_RecursiveDeleteWidget]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_RecursiveDeleteWidget);
    
    UNLK;
} /* it is wrapped in socket.c */
void Tw_MapWidget(tw_d TwD, twidget a1, twidget a2) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_MapWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_MapWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,uldat,a2); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_MapWidget]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_MapWidget);
    
    UNLK;
}
void Tw_UnMapWidget(tw_d TwD, twidget a1) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_UnMapWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_UnMapWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_UnMapWidget]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_UnMapWidget);
    
    UNLK;
}
void Tw_SetXYWidget(tw_d TwD, twidget a1, dat a2, dat a3) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_SetXYWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_SetXYWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(dat) + sizeof(dat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,dat,a2); Push(s,dat,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_SetXYWidget]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_SetXYWidget);
    
    UNLK;
}
tmsgport Tw_GetOwnerWidget(tw_d TwD, twidget a1) {
    tmsgport a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_GetOwnerWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_GetOwnerWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_GetOwnerWidget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tmsgport ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tmsgport  *)MyData;
#else
			    Pop(MyData, tmsgport , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_GetOwnerWidget);
			    a0 = (tmsgport )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_GetOwnerWidget);
			a0 = (tmsgport )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_GetOwnerWidget);
    
    UNLK;
    return TW_NOID;
}
void Tw_ExposeWidget(tw_d TwD, twidget a1, dat a2, dat a3, dat a4, dat a5, TW_CONST byte *a6, TW_CONST hwfont *a7, TW_CONST hwattr *a8) {
    
    uldat len6;
    uldat len7;
    uldat len8;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_ExposeWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_ExposeWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(dat) + sizeof(dat) + sizeof(dat) + sizeof(dat) + (len6 = a6 ? (a2*a3) * sizeof(byte) : 0, sizeof(uldat) + len6) + (len7 = a7 ? (a2*a3) * sizeof(hwfont) : 0, sizeof(uldat) + len7) + (len8 = a8 ? (a2*a3) * sizeof(hwattr) : 0, sizeof(uldat) + len8) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,dat,a2); Push(s,dat,a3); Push(s,dat,a4); Push(s,dat,a5); Push(s,uldat,len6); PushV(s,len6,a6); Push(s,uldat,len7); PushV(s,len7,a7); Push(s,uldat,len8); PushV(s,len8,a8); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_ExposeWidget]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_ExposeWidget);
    
    UNLK;
}
				    

tgadget Tw_CreateGadget(tw_d TwD, twidget a1, dat a2, dat a3, TW_CONST byte *a4, uldat a5, uldat a6, udat a7, hwcol a8, hwcol a9, hwcol a10, hwcol a11, dat a12, dat a13) {
    tgadget a0;
    DECL_MyReply
    uldat len4;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_CreateGadget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_CreateGadget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(dat) + sizeof(dat) + (len4 = a4 ? (a2*a3) * sizeof(byte) : 0, sizeof(uldat) + len4) + sizeof(uldat) + sizeof(uldat) + sizeof(udat) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(dat) + sizeof(dat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,dat,a2); Push(s,dat,a3); Push(s,uldat,len4); PushV(s,len4,a4); Push(s,uldat,a5); Push(s,uldat,a6); Push(s,udat,a7); Push(s,hwcol,a8); Push(s,hwcol,a9); Push(s,hwcol,a10); Push(s,hwcol,a11); Push(s,dat,a12); Push(s,dat,a13); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_CreateGadget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tgadget ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tgadget  *)MyData;
#else
			    Pop(MyData, tgadget , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_CreateGadget);
			    a0 = (tgadget )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_CreateGadget);
			a0 = (tgadget )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_CreateGadget);
    
    UNLK;
    return TW_NOID;
}

tgadget Tw_CreateButtonGadget(tw_d TwD, twidget a1, dat a2, dat a3, TW_CONST byte *a4, uldat a5, udat a6, hwcol a7, hwcol a8, hwcol a9, dat a10, dat a11) {
    tgadget a0;
    DECL_MyReply
    uldat len4;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_CreateButtonGadget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_CreateButtonGadget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(dat) + sizeof(dat) + (len4 = (a2*a3) * sizeof(byte)) + sizeof(uldat) + sizeof(udat) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(dat) + sizeof(dat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,dat,a2); Push(s,dat,a3); PushV(s,len4,a4); Push(s,uldat,a5); Push(s,udat,a6); Push(s,hwcol,a7); Push(s,hwcol,a8); Push(s,hwcol,a9); Push(s,dat,a10); Push(s,dat,a11); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_CreateButtonGadget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tgadget ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tgadget  *)MyData;
#else
			    Pop(MyData, tgadget , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_CreateButtonGadget);
			    a0 = (tgadget )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_CreateButtonGadget);
			a0 = (tgadget )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_CreateButtonGadget);
    
    UNLK;
    return TW_NOID;
}

void Tw_WriteTextsGadget(tw_d TwD, tgadget a1, byte a2, dat a3, dat a4, TW_CONST byte *a5, dat a6, dat a7) {
    
    uldat len5;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_WriteTextsGadget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_WriteTextsGadget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(byte) + sizeof(dat) + sizeof(dat) + (len5 = a5 ? (a2*a3) * sizeof(byte) : 0, sizeof(uldat) + len5) + sizeof(dat) + sizeof(dat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,byte,a2); Push(s,dat,a3); Push(s,dat,a4); Push(s,uldat,len5); PushV(s,len5,a5); Push(s,dat,a6); Push(s,dat,a7); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_WriteTextsGadget]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_WriteTextsGadget);
    
    UNLK;
}
void Tw_WriteHWFontsGadget(tw_d TwD, tgadget a1, byte a2, dat a3, dat a4, TW_CONST hwfont *a5, dat a6, dat a7) {
    
    uldat len5;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_WriteHWFontsGadget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_WriteHWFontsGadget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(byte) + sizeof(dat) + sizeof(dat) + (len5 = a5 ? (a2*a3) * sizeof(hwfont) : 0, sizeof(uldat) + len5) + sizeof(dat) + sizeof(dat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,byte,a2); Push(s,dat,a3); Push(s,dat,a4); Push(s,uldat,len5); PushV(s,len5,a5); Push(s,dat,a6); Push(s,dat,a7); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_WriteHWFontsGadget]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_WriteHWFontsGadget);
    
    UNLK;
}

									
void Tw_Create4MenuRow(tw_d TwD, twindow a1, udat a2, byte a3, ldat a4, TW_CONST byte *a5) {
    
    uldat len5;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_Create4MenuRow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_Create4MenuRow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(udat) + sizeof(byte) + sizeof(ldat) + (len5 = (a4) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,udat,a2); Push(s,byte,a3); Push(s,ldat,a4); PushV(s,len5,a5); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_Create4MenuRow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_Create4MenuRow);
    
    UNLK;
}

twindow Tw_CreateWindow(tw_d TwD, dat a1, TW_CONST byte *a2, TW_CONST hwcol *a3, tmenu a4, hwcol a5, uldat a6, uldat a7, uldat a8, dat a9, dat a10, dat a11) {
    twindow a0;
    DECL_MyReply
    uldat len2;
    uldat len3;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_CreateWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_CreateWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(dat) + (len2 = (a1) * sizeof(byte)) + (len3 = a3 ? (a1) * sizeof(hwcol) : 0, sizeof(uldat) + len3) + sizeof(uldat) + sizeof(hwcol) + sizeof(uldat) + sizeof(uldat) + sizeof(uldat) + sizeof(dat) + sizeof(dat) + sizeof(dat) );
            if (WQLeft(My)) {
                Push(s,dat,a1); PushV(s,len2,a2); Push(s,uldat,len3); PushV(s,len3,a3); Push(s,uldat,a4); Push(s,hwcol,a5); Push(s,uldat,a6); Push(s,uldat,a7); Push(s,uldat,a8); Push(s,dat,a9); Push(s,dat,a10); Push(s,dat,a11); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_CreateWindow]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(twindow ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(twindow  *)MyData;
#else
			    Pop(MyData, twindow , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_CreateWindow);
			    a0 = (twindow )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_CreateWindow);
			a0 = (twindow )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_CreateWindow);
    
    UNLK;
    return TW_NOID;
}
twindow Tw_Create4MenuWindow(tw_d TwD, tmenu a1) {
    twindow a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_Create4MenuWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_Create4MenuWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_Create4MenuWindow]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(twindow ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(twindow  *)MyData;
#else
			    Pop(MyData, twindow , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_Create4MenuWindow);
			    a0 = (twindow )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_Create4MenuWindow);
			a0 = (twindow )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_Create4MenuWindow);
    
    UNLK;
    return TW_NOID;
}
void Tw_WriteAsciiWindow(tw_d TwD, twindow a1, ldat a2, TW_CONST byte *a3) {
    
    uldat len3;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_WriteAsciiWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_WriteAsciiWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(ldat) + (len3 = (a2) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,ldat,a2); PushV(s,len3,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_WriteAsciiWindow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_WriteAsciiWindow);
    
    UNLK;
}
void Tw_WriteStringWindow(tw_d TwD, twindow a1, ldat a2, TW_CONST byte *a3) {
    
    uldat len3;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_WriteStringWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_WriteStringWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(ldat) + (len3 = (a2) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,ldat,a2); PushV(s,len3,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_WriteStringWindow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_WriteStringWindow);
    
    UNLK;
}
void Tw_WriteHWFontWindow(tw_d TwD, twindow a1, ldat a2, TW_CONST hwfont *a3) {
    
    uldat len3;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_WriteHWFontWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_WriteHWFontWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(ldat) + (len3 = (a2) * sizeof(hwfont)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,ldat,a2); PushV(s,len3,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_WriteHWFontWindow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_WriteHWFontWindow);
    
    UNLK;
}
void Tw_WriteHWAttrWindow(tw_d TwD, twindow a1, dat a2, dat a3, ldat a4, TW_CONST hwattr *a5) {
    
    uldat len5;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_WriteHWAttrWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_WriteHWAttrWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(dat) + sizeof(dat) + sizeof(ldat) + (len5 = (a4) * sizeof(hwattr)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,dat,a2); Push(s,dat,a3); Push(s,ldat,a4); PushV(s,len5,a5); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_WriteHWAttrWindow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_WriteHWAttrWindow);
    
    UNLK;
}
void Tw_WriteRowWindow(tw_d TwD, twindow a1, ldat a2, TW_CONST byte *a3) {
    
    uldat len3;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_WriteRowWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_WriteRowWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(ldat) + (len3 = (a2) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,ldat,a2); PushV(s,len3,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_WriteRowWindow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_WriteRowWindow);
    
    UNLK;
}

void Tw_GotoXYWindow(tw_d TwD, twindow a1, ldat a2, ldat a3) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_GotoXYWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_GotoXYWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(ldat) + sizeof(ldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,ldat,a2); Push(s,ldat,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_GotoXYWindow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_GotoXYWindow);
    
    UNLK;
}
void Tw_SetColTextWindow(tw_d TwD, twindow a1, hwcol a2) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_SetColTextWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_SetColTextWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(hwcol) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,hwcol,a2); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_SetColTextWindow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_SetColTextWindow);
    
    UNLK;
}
void Tw_SetColorsWindow(tw_d TwD, twindow a1, udat a2, hwcol a3, hwcol a4, hwcol a5, hwcol a6, hwcol a7, hwcol a8, hwcol a9, hwcol a10, hwcol a11) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_SetColorsWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_SetColorsWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(udat) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,udat,a2); Push(s,hwcol,a3); Push(s,hwcol,a4); Push(s,hwcol,a5); Push(s,hwcol,a6); Push(s,hwcol,a7); Push(s,hwcol,a8); Push(s,hwcol,a9); Push(s,hwcol,a10); Push(s,hwcol,a11); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_SetColorsWindow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_SetColorsWindow);
    
    UNLK;
}
void Tw_ConfigureWindow(tw_d TwD, twindow a1, byte a2, dat a3, dat a4, dat a5, dat a6, dat a7, dat a8) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_ConfigureWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_ConfigureWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(byte) + sizeof(dat) + sizeof(dat) + sizeof(dat) + sizeof(dat) + sizeof(dat) + sizeof(dat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,byte,a2); Push(s,dat,a3); Push(s,dat,a4); Push(s,dat,a5); Push(s,dat,a6); Push(s,dat,a7); Push(s,dat,a8); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_ConfigureWindow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_ConfigureWindow);
    
    UNLK;
}
void Tw_ResizeWindow(tw_d TwD, twindow a1, dat a2, dat a3) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_ResizeWindow]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_ResizeWindow)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(dat) + sizeof(dat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,dat,a2); Push(s,dat,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_ResizeWindow]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_ResizeWindow);
    
    UNLK;
}

twidget Tw_FindWidgetAtWidget(tw_d TwD, twidget a1, dat a2, dat a3) {
    twidget a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FindWidgetAtWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FindWidgetAtWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(dat) + sizeof(dat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,dat,a2); Push(s,dat,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FindWidgetAtWidget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(twidget ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(twidget  *)MyData;
#else
			    Pop(MyData, twidget , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FindWidgetAtWidget);
			    a0 = (twidget )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FindWidgetAtWidget);
			a0 = (twidget )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FindWidgetAtWidget);
    
    UNLK;
    return TW_NOID;
}

tgroup Tw_CreateGroup(tw_d TwD) {
    tgroup a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_CreateGroup]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_CreateGroup)) != TW_NOID)) {
	if (InitRS(TwD)) {
            
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_CreateGroup]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tgroup ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tgroup  *)MyData;
#else
			    Pop(MyData, tgroup , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_CreateGroup);
			    a0 = (tgroup )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_CreateGroup);
			a0 = (tgroup )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_CreateGroup);
    
    UNLK;
    return TW_NOID;
}
void Tw_InsertGadgetGroup(tw_d TwD, tgroup a1, tgadget a2) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_InsertGadgetGroup]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_InsertGadgetGroup)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,uldat,a2); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_InsertGadgetGroup]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_InsertGadgetGroup);
    
    UNLK;
}
void Tw_RemoveGadgetGroup(tw_d TwD, tgroup a1, tgadget a2) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_RemoveGadgetGroup]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_RemoveGadgetGroup)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,uldat,a2); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_RemoveGadgetGroup]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_RemoveGadgetGroup);
    
    UNLK;
}

tgadget Tw_GetSelectedGadgetGroup(tw_d TwD, tgroup a1) {
    tgadget a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_GetSelectedGadgetGroup]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_GetSelectedGadgetGroup)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_GetSelectedGadgetGroup]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tgadget ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tgadget  *)MyData;
#else
			    Pop(MyData, tgadget , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_GetSelectedGadgetGroup);
			    a0 = (tgadget )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_GetSelectedGadgetGroup);
			a0 = (tgadget )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_GetSelectedGadgetGroup);
    
    UNLK;
    return TW_NOID;
}
void Tw_SetSelectedGadgetGroup(tw_d TwD, tgroup a1, tgadget a2) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_SetSelectedGadgetGroup]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_SetSelectedGadgetGroup)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,uldat,a2); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_SetSelectedGadgetGroup]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_SetSelectedGadgetGroup);
    
    UNLK;
}

tmenuitem Tw_Create4MenuMenuItem(tw_d TwD, tmenu a1, twindow a2, byte a3, dat a4, TW_CONST byte *a5) {
    tmenuitem a0;
    DECL_MyReply
    uldat len5;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_Create4MenuMenuItem]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_Create4MenuMenuItem)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(uldat) + sizeof(byte) + sizeof(dat) + (len5 = (a4) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,uldat,a2); Push(s,byte,a3); Push(s,dat,a4); PushV(s,len5,a5); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_Create4MenuMenuItem]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tmenuitem ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tmenuitem  *)MyData;
#else
			    Pop(MyData, tmenuitem , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_Create4MenuMenuItem);
			    a0 = (tmenuitem )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_Create4MenuMenuItem);
			a0 = (tmenuitem )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_Create4MenuMenuItem);
    
    UNLK;
    return TW_NOID;
}
uldat Tw_Create4MenuCommonMenuItem(tw_d TwD, tmenu a1) {
    uldat a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_Create4MenuCommonMenuItem]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_Create4MenuCommonMenuItem)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_Create4MenuCommonMenuItem]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(uldat ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(uldat  *)MyData;
#else
			    Pop(MyData, uldat , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_Create4MenuCommonMenuItem);
			    a0 = (uldat )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_Create4MenuCommonMenuItem);
			a0 = (uldat )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_Create4MenuCommonMenuItem);
    
    UNLK;
    return (uldat)0;
}

tmenu Tw_CreateMenu(tw_d TwD, hwcol a1, hwcol a2, hwcol a3, hwcol a4, hwcol a5, hwcol a6, byte a7) {
    tmenu a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_CreateMenu]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_CreateMenu)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(hwcol) + sizeof(byte) );
            if (WQLeft(My)) {
                Push(s,hwcol,a1); Push(s,hwcol,a2); Push(s,hwcol,a3); Push(s,hwcol,a4); Push(s,hwcol,a5); Push(s,hwcol,a6); Push(s,byte,a7); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_CreateMenu]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tmenu ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tmenu  *)MyData;
#else
			    Pop(MyData, tmenu , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_CreateMenu);
			    a0 = (tmenu )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_CreateMenu);
			a0 = (tmenu )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_CreateMenu);
    
    UNLK;
    return TW_NOID;
}
void Tw_SetInfoMenu(tw_d TwD, tmenu a1, byte a2, ldat a3, TW_CONST byte *a4, TW_CONST hwcol *a5) {
    
    uldat len4;
    uldat len5;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_SetInfoMenu]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_SetInfoMenu)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(byte) + sizeof(ldat) + (len4 = (a3) * sizeof(byte)) + (len5 = a5 ? (a3) * sizeof(hwcol) : 0, sizeof(uldat) + len5) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,byte,a2); Push(s,ldat,a3); PushV(s,len4,a4); Push(s,uldat,len5); PushV(s,len5,a5); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_SetInfoMenu]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_SetInfoMenu);
    
    UNLK;
}

tmsgport Tw_CreateMsgPort(tw_d TwD, byte a1, TW_CONST byte *a2, time_t a3, frac_t a4, byte a5) {
    tmsgport a0;
    DECL_MyReply
    uldat len2;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_CreateMsgPort]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_CreateMsgPort)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(byte) + (len2 = (a1) * sizeof(byte)) + sizeof(time_t) + sizeof(frac_t) + sizeof(byte) );
            if (WQLeft(My)) {
                Push(s,byte,a1); PushV(s,len2,a2); Push(s,time_t,a3); Push(s,frac_t,a4); Push(s,byte,a5); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_CreateMsgPort]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tmsgport ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tmsgport  *)MyData;
#else
			    Pop(MyData, tmsgport , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_CreateMsgPort);
			    a0 = (tmsgport )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_CreateMsgPort);
			a0 = (tmsgport )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_CreateMsgPort);
    
    UNLK;
    return TW_NOID;
}
tmsgport Tw_FindMsgPort(tw_d TwD, tmsgport a1, byte a2, TW_CONST byte *a3) {
    tmsgport a0;
    DECL_MyReply
    uldat len3;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FindMsgPort]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FindMsgPort)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(byte) + (len3 = (a2) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,byte,a2); PushV(s,len3,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FindMsgPort]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tmsgport ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tmsgport  *)MyData;
#else
			    Pop(MyData, tmsgport , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FindMsgPort);
			    a0 = (tmsgport )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FindMsgPort);
			a0 = (tmsgport )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FindMsgPort);
    
    UNLK;
    return TW_NOID;
}

void Tw_BgImageScreen(tw_d TwD, tscreen a1, dat a2, dat a3, TW_CONST hwattr *a4) {
    
    uldat len4;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_BgImageScreen]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_BgImageScreen)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(dat) + sizeof(dat) + (len4 = (a2*a3) * sizeof(hwattr)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,dat,a2); Push(s,dat,a3); PushV(s,len4,a4); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_BgImageScreen]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_BgImageScreen);
    
    UNLK;
}

tobj Tw_PrevObj(tw_d TwD, tobj a1) {
    tobj a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_PrevObj]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_PrevObj)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_PrevObj]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tobj ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tobj  *)MyData;
#else
			    Pop(MyData, tobj , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_PrevObj);
			    a0 = (tobj )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_PrevObj);
			a0 = (tobj )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_PrevObj);
    
    UNLK;
    return TW_NOID;
}
tobj Tw_NextObj(tw_d TwD, tobj a1) {
    tobj a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_NextObj]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_NextObj)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_NextObj]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tobj ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tobj  *)MyData;
#else
			    Pop(MyData, tobj , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_NextObj);
			    a0 = (tobj )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_NextObj);
			a0 = (tobj )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_NextObj);
    
    UNLK;
    return TW_NOID;
}
tobj Tw_ParentObj(tw_d TwD, tobj a1) {
    tobj a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_ParentObj]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_ParentObj)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_ParentObj]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tobj ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tobj  *)MyData;
#else
			    Pop(MyData, tobj , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_ParentObj);
			    a0 = (tobj )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_ParentObj);
			a0 = (tobj )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_ParentObj);
    
    UNLK;
    return TW_NOID;
}

tgadget   Tw_G_PrevGadget(tw_d TwD, tgadget  a1) {
    tgadget   a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_G_PrevGadget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_G_PrevGadget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_G_PrevGadget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tgadget   ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tgadget    *)MyData;
#else
			    Pop(MyData, tgadget   , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_G_PrevGadget);
			    a0 = (tgadget   )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_G_PrevGadget);
			a0 = (tgadget   )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_G_PrevGadget);
    
    UNLK;
    return TW_NOID;
}
tgadget   Tw_G_NextGadget(tw_d TwD, tgadget  a1) {
    tgadget   a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_G_NextGadget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_G_NextGadget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_G_NextGadget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tgadget   ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tgadget    *)MyData;
#else
			    Pop(MyData, tgadget   , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_G_NextGadget);
			    a0 = (tgadget   )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_G_NextGadget);
			a0 = (tgadget   )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_G_NextGadget);
    
    UNLK;
    return TW_NOID;
}
tgroup    Tw_GroupGadget(tw_d TwD, tgadget  a1) {
    tgroup    a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_GroupGadget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_GroupGadget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_GroupGadget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tgroup    ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tgroup     *)MyData;
#else
			    Pop(MyData, tgroup    , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_GroupGadget);
			    a0 = (tgroup    )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_GroupGadget);
			a0 = (tgroup    )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_GroupGadget);
    
    UNLK;
    return TW_NOID;
}

twidget   Tw_O_PrevWidget(tw_d TwD, twidget  a1) {
    twidget   a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_O_PrevWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_O_PrevWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_O_PrevWidget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(twidget   ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(twidget    *)MyData;
#else
			    Pop(MyData, twidget   , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_O_PrevWidget);
			    a0 = (twidget   )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_O_PrevWidget);
			a0 = (twidget   )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_O_PrevWidget);
    
    UNLK;
    return TW_NOID;
}
twidget   Tw_O_NextWidget(tw_d TwD, twidget  a1) {
    twidget   a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_O_NextWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_O_NextWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_O_NextWidget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(twidget   ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(twidget    *)MyData;
#else
			    Pop(MyData, twidget   , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_O_NextWidget);
			    a0 = (twidget   )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_O_NextWidget);
			a0 = (twidget   )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_O_NextWidget);
    
    UNLK;
    return TW_NOID;
}
tmsgport  Tw_OwnerWidget(tw_d TwD, twidget  a1) {
    tmsgport  a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_OwnerWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_OwnerWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_OwnerWidget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tmsgport  ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tmsgport   *)MyData;
#else
			    Pop(MyData, tmsgport  , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_OwnerWidget);
			    a0 = (tmsgport  )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_OwnerWidget);
			a0 = (tmsgport  )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_OwnerWidget);
    
    UNLK;
    return TW_NOID;
}

tscreen   Tw_FirstScreen(tw_d TwD) {
    tscreen   a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FirstScreen]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FirstScreen)) != TW_NOID)) {
	if (InitRS(TwD)) {
            
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FirstScreen]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tscreen   ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tscreen    *)MyData;
#else
			    Pop(MyData, tscreen   , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FirstScreen);
			    a0 = (tscreen   )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FirstScreen);
			a0 = (tscreen   )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FirstScreen);
    
    UNLK;
    return TW_NOID;
}
twidget   Tw_FirstWidget(tw_d TwD, twidget  a1) {
    twidget   a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FirstWidget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FirstWidget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FirstWidget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(twidget   ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(twidget    *)MyData;
#else
			    Pop(MyData, twidget   , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FirstWidget);
			    a0 = (twidget   )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FirstWidget);
			a0 = (twidget   )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FirstWidget);
    
    UNLK;
    return TW_NOID;
}
tmsgport  Tw_FirstMsgPort(tw_d TwD) {
    tmsgport  a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FirstMsgPort]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FirstMsgPort)) != TW_NOID)) {
	if (InitRS(TwD)) {
            
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FirstMsgPort]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tmsgport  ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tmsgport   *)MyData;
#else
			    Pop(MyData, tmsgport  , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FirstMsgPort);
			    a0 = (tmsgport  )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FirstMsgPort);
			a0 = (tmsgport  )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FirstMsgPort);
    
    UNLK;
    return TW_NOID;
}
tmenu     Tw_FirstMenu(tw_d TwD, tmsgport a1) {
    tmenu     a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FirstMenu]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FirstMenu)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FirstMenu]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tmenu     ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tmenu      *)MyData;
#else
			    Pop(MyData, tmenu     , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FirstMenu);
			    a0 = (tmenu     )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FirstMenu);
			a0 = (tmenu     )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FirstMenu);
    
    UNLK;
    return TW_NOID;
}
twidget   Tw_FirstW(tw_d TwD, tmsgport a1) {
    twidget   a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FirstW]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FirstW)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FirstW]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(twidget   ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(twidget    *)MyData;
#else
			    Pop(MyData, twidget   , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FirstW);
			    a0 = (twidget   )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FirstW);
			a0 = (twidget   )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FirstW);
    
    UNLK;
    return TW_NOID;
}
tgroup    Tw_FirstGroup(tw_d TwD, tmsgport a1) {
    tgroup    a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FirstGroup]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FirstGroup)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FirstGroup]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tgroup    ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tgroup     *)MyData;
#else
			    Pop(MyData, tgroup    , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FirstGroup);
			    a0 = (tgroup    )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FirstGroup);
			a0 = (tgroup    )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FirstGroup);
    
    UNLK;
    return TW_NOID;
}
tmutex    Tw_FirstMutex(tw_d TwD, tmsgport a1) {
    tmutex    a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FirstMutex]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FirstMutex)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FirstMutex]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tmutex    ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tmutex     *)MyData;
#else
			    Pop(MyData, tmutex    , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FirstMutex);
			    a0 = (tmutex    )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FirstMutex);
			a0 = (tmutex    )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FirstMutex);
    
    UNLK;
    return TW_NOID;
}
tmenuitem Tw_FirstMenuItem(tw_d TwD, tmenu    a1) {
    tmenuitem a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FirstMenuItem]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FirstMenuItem)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FirstMenuItem]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tmenuitem ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tmenuitem  *)MyData;
#else
			    Pop(MyData, tmenuitem , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FirstMenuItem);
			    a0 = (tmenuitem )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FirstMenuItem);
			a0 = (tmenuitem )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FirstMenuItem);
    
    UNLK;
    return TW_NOID;
}
tgadget   Tw_FirstGadget(tw_d TwD, tgroup   a1) {
    tgadget   a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_FirstGadget]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_FirstGadget)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_FirstGadget]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tgadget   ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tgadget    *)MyData;
#else
			    Pop(MyData, tgadget   , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_FirstGadget);
			    a0 = (tgadget   )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_FirstGadget);
			a0 = (tgadget   )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_FirstGadget);
    
    UNLK;
    return TW_NOID;
}


dat Tw_GetDisplayWidth(tw_d TwD) {
    dat a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_GetDisplayWidth]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_GetDisplayWidth)) != TW_NOID)) {
	if (InitRS(TwD)) {
            
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_GetDisplayWidth]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(dat ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(dat  *)MyData;
#else
			    Pop(MyData, dat , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_GetDisplayWidth);
			    a0 = (dat )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_GetDisplayWidth);
			a0 = (dat )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_GetDisplayWidth);
    
    UNLK;
    return (dat)0;
}
dat Tw_GetDisplayHeight(tw_d TwD) {
    dat a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_GetDisplayHeight]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_GetDisplayHeight)) != TW_NOID)) {
	if (InitRS(TwD)) {
            
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_GetDisplayHeight]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(dat ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(dat  *)MyData;
#else
			    Pop(MyData, dat , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_GetDisplayHeight);
			    a0 = (dat )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_GetDisplayHeight);
			a0 = (dat )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_GetDisplayHeight);
    
    UNLK;
    return (dat)0;
}

byte Tw_SendToMsgPort(tw_d TwD, tmsgport a1, udat a2, TW_CONST byte *a3) {
    byte a0;
    DECL_MyReply
    uldat len3;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_SendToMsgPort]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_SendToMsgPort)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(udat) + (len3 = (a2) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,udat,a2); PushV(s,len3,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_SendToMsgPort]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(byte ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(byte  *)MyData;
#else
			    Pop(MyData, byte , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_SendToMsgPort);
			    a0 = (byte )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_SendToMsgPort);
			a0 = (byte )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_SendToMsgPort);
    
    UNLK;
    return (byte)0;
}
void Tw_BlindSendToMsgPort(tw_d TwD, tmsgport a1, udat a2, TW_CONST byte *a3) {
    
    uldat len3;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_BlindSendToMsgPort]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_BlindSendToMsgPort)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(udat) + (len3 = (a2) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,udat,a2); PushV(s,len3,a3); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_BlindSendToMsgPort]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_BlindSendToMsgPort);
    
    UNLK;
}

tobj Tw_GetOwnerSelection(tw_d TwD) {
    tobj a0;
    DECL_MyReply
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_GetOwnerSelection]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_GetOwnerSelection)) != TW_NOID)) {
	if (InitRS(TwD)) {
            
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_GetOwnerSelection]);
                    if ((MyReply = (void *)Wait4Reply(TwD, My)) && (INIT_MyReply MyCode == OK_MAGIC)) {
			if (MyLen == 2*sizeof(uldat) + sizeof(tobj ))
#if TW_CAN_UNALIGNED != 0
			    a0 = *(tobj  *)MyData;
#else
			    Pop(MyData, tobj , a0);
#endif
			else {
			    FailedCall(TwD, TW_ESTRANGE_CALL, order_GetOwnerSelection);
			    a0 = (tobj )TW_NOID;
			}
		    } else {
			FailedCall(TwD, MyReply && MyReply->Code != (uldat)-1 ?
				   TW_EFAILED_ARG_CALL : TW_EFAILED_CALL, order_GetOwnerSelection);
			a0 = (tobj )TW_NOID;
		    }
		    if (MyReply)
			KillReply(TwD, (byte *)MyReply, MyLen);
		    UNLK;return a0;
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_GetOwnerSelection);
    
    UNLK;
    return TW_NOID;
}
void Tw_SetOwnerSelection(tw_d TwD, time_t a1, frac_t a2) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_SetOwnerSelection]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_SetOwnerSelection)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(time_t) + sizeof(frac_t) );
            if (WQLeft(My)) {
                Push(s,time_t,a1); Push(s,frac_t,a2); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_SetOwnerSelection]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_SetOwnerSelection);
    
    UNLK;
}
void Tw_RequestSelection(tw_d TwD, tobj a1, uldat a2) {
    
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_RequestSelection]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_RequestSelection)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(uldat) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,uldat,a2); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_RequestSelection]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_RequestSelection);
    
    UNLK;
}
void Tw_NotifySelection(tw_d TwD, tobj a1, uldat a2, uldat a3, TW_CONST byte *a4, uldat a5, TW_CONST byte *a6) {
    
    uldat len4;
    uldat len6;
    uldat My;
    LOCK;
    if (Fd != TW_NOFD && ((My = id_Tw[order_NotifySelection]) != TW_NOID ||
		       (My = FindFunctionId(TwD, order_NotifySelection)) != TW_NOID)) {
	if (InitRS(TwD)) {
            My = (0 + sizeof(uldat) + sizeof(uldat) + sizeof(uldat) + (len4 = (TW_MAX_MIMELEN) * sizeof(byte)) + sizeof(uldat) + (len6 = (a5) * sizeof(byte)) );
            if (WQLeft(My)) {
                Push(s,uldat,a1); Push(s,uldat,a2); Push(s,uldat,a3); PushV(s,len4,a4); Push(s,uldat,a5); PushV(s,len6,a6); 
	            Send(TwD, (My = NextSerial(TwD)), id_Tw[order_NotifySelection]);
                    UNLK;return;
            }
	}
	/* still here? must be out of memory! */
	Errno = TW_ENO_MEM;
	Fail(TwD);
    } else if (Fd != TW_NOFD)
	FailedCall(TwD, TW_ENO_FUNCTION, order_NotifySelection);
    
    UNLK;
}



