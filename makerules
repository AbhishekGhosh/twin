#
# Top level, common rules
#

#
# do NOT touch this
#
ifneq ($(wildcard $(TOPDIR)/makeautoconf),)
  include $(TOPDIR)/makeautoconf
endif


#
# choose your favorite C compiler.
# keep commented to let `./configure' autodetect it
# CC=gcc


#
# Uncomment this to turn debugging on
# DEBUG=y

#
# compile/link flags. Used if no CFLAGS/LDFLAGS given in `make' command line
#
ifdef DEBUG
 CFLAGS+=-g -DINLINE=static
 LDFLAGS+=-g
else
 ifdef PROFILE
   CFLAGS+=-p -pg
   LDFLAGS+=-p -pg
 else
   ifeq ($(CC),gcc)
     CFLAGS+=-O2 -fomit-frame-pointer
   else
     # detected by `./configure' :
     CFLAGS+=$(CC_AC_FLAGS)
   endif
   LDFLAGS+=-s
 endif
endif

#
# how picky should your compiler be? uncomment for paranoid gcc settings.
# PARANOID_GCC=1

#
# apply known-good GCC compiler flags.
#
ifeq ($(CC),gcc)
  CFLAGS+=-pipe -Wall -Wshadow -Wno-uninitialized -Winline
  ifdef PARANOID_GCC
    CFLAGS+=-Wstrict-prototypes -Wcast-qual -Wcast-align -Wpointer-arith -Wbad-function-cast -Waggregate-return
  endif
endif

# try to get some extensions if available (recursive pthread mutexes, grantpt(), ...)
CFLAGS+=-D_GNU_SOURCE -D_XOPEN_SOURCE

#
# save user-specified or above default values in the right place
#
CC_FLAGS+=$(CFLAGS) $(EXTRA_CFLAGS)
LD_FLAGS+=$(LDFLAGS) $(EXTRA_LDFLAGS)

#
# set 'install' program
# keep commented to let `./configure' autodetect it
#
# INSTALL=install

#
# install with 644 permission:
#
INSTALL-TXT=$(INSTALL) -m 644

#
# set `ar' archiver...
#
AR=ar


#
# set `ranlib' archiver (not needed on Linux and other 'modern' OS)
#
#RANLIB=ranlib

#
# `cp -f' : `cp' with force overwrite
#
CP=cp -f

#
# `ln -f -s' : `ln' with soft links, force overwrite
#
LN=ln -f -s

#
# `mkdir -p' or `mkdirhier' : make a directory and all missing directory parents
#
MKDIR=mkdir -p
#MKDIR=mkdirhier


#
# choose a variation of `echo' that interprets \n as newline.
# keep commented to enable autodetection.
#
#ECHO=echo
#ECHO=echo -e

#
# where is bash on your system?
# keep commented to enable autodetection.
#
#BASH=/bin/bash


#
# only if you know what you are doing:
# options to used to link shared libraries.
# keep commented to enable autodetection.
#
# this is for Linux and *BSD
#LD_FLAGS_SOLIB_NAME=-lc -shared -Wl,-soname,
#LD_FLAGS_SOLIB=-lc -shared
#
# and this for SunOS
#LD_FLAGS_SOLIB_NAME=-lc -shared -Wl,-h,
#LD_FLAGS_SOLIB=-lc -shared


#
# --------------- no user-serviceable parts below this line ----------------
#

#
# m4 preprocessor
#
M4=m4

ifeq ($(wildcard $(TOPDIR)/makeosvalues),)
  OS:=$(shell uname)
  GNULD:=$(filter GNU,$(shell ld -V))
  ifeq ($(ECHO),)
    ifeq ($(strip $(shell echo -e "\n")),)
      ECHO:=echo -e
    else
      ECHO:=echo
    endif
    ifeq ($(strip $(shell ( echo "test\c"; echo "test" ) | grep c)),)
      ECHO_N:=
      ECHO_C:=\c
    else
      ECHO_N:=-n
      ECHO_C:=
    endif
  endif
  ifeq ($(BASH),)
    BASH:=$(shell if [ -x /bin/bash ]; then echo /bin/bash; \
            else if bash -c : 2>/dev/null; then echo bash; \
	    else if [ -x "$$BASH" ]; then echo $$BASH; \
	    else echo sh; fi; fi; fi)
  endif
  ifeq ($(LD_FLAGS_SOLIB_NAME),)
    ifeq ($(GNULD),GNU)
      # this is correct for at least Linux and FreeBSD.
      # for the others, it is just a guess
      LD_FLAGS_SOLIB_NAME=-lc -shared -Wl,-soname,
      LD_FLAGS_SOLIB=-lc -shared
    else
      # this is ok at least on SunOS with native linker
      LD_FLAGS_SOLIB_NAME=-lc -shared -Wl,-h,
      LD_FLAGS_SOLIB=-lc -shared
    endif
  endif
endif

$(TOPDIR)/makeosvalues: $(TOPDIR)/makerules
	@$(ECHO) "OS:=$(OS)" > $@ ; \
	 $(ECHO) "GNULD:=$(GNULD)" >> $@ ; \
	 $(ECHO) "ECHO:=$(ECHO)" >> $@ ; \
	 $(ECHO) "ECHO_N:=$(ECHO_N)" >> $@ ; \
	 $(ECHO) "ECHO_C:=$(ECHO_C)" >> $@ ; \
	 $(ECHO) "BASH:=$(BASH)" >> $@ ; \
	 $(ECHO) "LD_FLAGS_SOLIB_NAME:=$(LD_FLAGS_SOLIB_NAME)" >> $@ ; \
	 $(ECHO) "LD_FLAGS_SOLIB:=$(LD_FLAGS_SOLIB)" >> $@

ifeq ($(filter -r,$(MAKEFLAGS)),)
  MAKEFLAGS+=-r
endif

TWIN_VERSION_STR=0.4.2

CC_FLAGS+=-I$(TOPDIR)/include

MODFLAGS+=-fPIC -DCONF_THIS_MODULE


CONF=$(TOPDIR)/conf/conf.current

#
# once shared libraries are installed, it's ok to link just with
# one of -lTutf, -lTw or -lTT
#
# but linking against $(TOPDIR)/libs/libTT/libTT.so fails
# if there is no libTw.so in the linker path (as it happens
# while building twin for the first time), so we need to use
# -Wl,-rpath-link <directory> for each dependency library.
#
# when using static libraries, we must always explicitly
# link all of them... (linker knows no dependencies with them)
#

ifeq ($(CONF__SHLIBS),n)
  LD_LIBTUTF:=$(TOPDIR)/libs/libTutf/libTutf.a
  LD_LIBTW:=$(TOPDIR)/libs/libTw/libTw.a
  LD_LIBTT:=$(TOPDIR)/libs/libTT/libTT.a
  
  ifeq ($(CONF__MODULES),y)
    LD_LIBTT+=$(LD_LIBDL)
  endif
  ifeq ($(CONF__UNICODE),y)
    LD_LIBTT+=$(LD_LIBTUTF)
  endif
  ifeq ($(CONF_SOCKET_GZ),y)
    LD_LIBTW+=-lz
  endif
  ifeq ($(CONF_SOCKET_PTHREADS),y)
    LD_LIBTW+=$(LD_LIBPTHREAD_WEAK)
    LD_LIBTT+=$(LD_LIBPTHREAD_WEAK)
  endif
  ifeq ($(CONF_TT_HW_TWIN),y)
    LD_LIBTT+=$(LD_LIBTW)
  endif
  ifeq ($(CONF_TT_HW_GTK),y)
    LD_LIBTT+=$(LD_LIBGTK)
  endif
else
  LD_LIBTUTF:=-L$(TOPDIR)/libs/libTutf -lTutf
  LD_LIBTW:=-L$(TOPDIR)/libs/libTw -lTw
  LD_LIBTT:=-L$(TOPDIR)/libs/libTT -lTT
  
  ifeq ($(GNULD),GNU)
    # ok, ld is GNU ld
    ifeq ($(CONF__UNICODE),y)
      LD_LIBTT+=-Wl,-rpath-link,$(TOPDIR)/libs/libTutf
    endif
    ifeq ($(CONF_TT_HW_TWIN),y)
      LD_LIBTT+=-Wl,-rpath-link,$(TOPDIR)/libs/libTw
    endif
  else
    ifeq ($(CONF__UNICODE),y)
      LD_LIBTT+=$(LD_LIBTUTF)
    endif
    ifeq ($(CONF_TT_HW_TWIN),y)
      LD_LIBTT+=$(LD_LIBTW)
    endif
    ifeq ($(CONF_TT_HW_GTK),y)
      LD_LIBTT+=$(LD_LIBGTK)
    endif
  endif
endif


config:
	@echo Starting configure for twin $(TWIN_VERSION_STR) ... ; \
	echo
	cd $(TOPDIR) && \
	$(BASH) scripts/Configure.tty

menuconf menuconfig:
	@echo Starting menu-dialog configure for twin $(TWIN_VERSION_STR) ... ; \
	echo
	cd $(TOPDIR) && \
	$(BASH) scripts/Configure.dialog

gconf gconfig:
	@echo Starting menu-gdialog configure for twin $(TWIN_VERSION_STR) ... ; \
	echo
	cd $(TOPDIR) && \
	$(BASH) scripts/Configure.dialog 254 gdialog

nullconfig:
	cd $(TOPDIR) && \
	$(BASH) scripts/Configure.tty < /dev/null > /dev/null

	



# collect together in $(OBJS) all objs from $(BINS) looking in $(OBJS_xxx)

OBJS:=$(foreach B,$(BINS),$(OBJS_$(B)))

# same with $(MODOBJS) from $(MODBINS)
MODOBJS:=$(foreach B,$(MODBINS),$(OBJS_$(B)))

# same with $(ARLIBOBJS) from $(ARLIBS)
ARLIBOBJS:=$(foreach B,$(ARLIBS),$(OBJS_$(B)))

# same with $(COLLECTOBJS) from $(COLLECTS)
COLLECTOBJS:=$(foreach B,$(COLLECTS),$(OBJS_$(B)))


# set correct CC_FLAGS for objs compiled as modules
ifneq ($(MODOBJS),)
  _ALLFLAGS:=$(strip $(patsubst %,CC_FLAGS_%+=$(MODFLAGS)\n,$(MODOBJS)))
endif

_ALLBINS:=$(strip $(BINS) $(MODBINS) $(ARLIBS) $(COLLECTS))

_ALLOBJS:=$(strip $(OBJS) $(MODOBJS) $(ARLIBOBJS) $(COLLECTOBJS) $(EXCL_OBJS))

#
# try to autodetect whether a %.o object comes from
# %.c, %.S or %.C source:
# if a %.S or %.C file exists, take it, else assume %.c
#
#_ALLSRCS:=$(strip $(subst .o,.c,$(filter %.o,$(_ALLOBJS))))
#
__ALLOBJS:=$(filter %.o,$(_ALLOBJS))
__ALLSRCS_ASM:=$(strip $(wildcard $(subst .o,.S,$(__ALLOBJS))))
__ALLSRCS_CXX:=$(strip $(wildcard $(subst .o,.C,$(__ALLOBJS))))
__ALLOBJS_ASM:=$(subst .S,.o,$(__ALLSRCS_ASM))
__ALLOBJS_CXX:=$(subst .S,.o,$(__ALLSRCS_CXX))

_ALLSRCS:=$(subst .o,.c,$(filter-out $(__ALLOBJS_ASM) $(__ALLOBJS_CXX), $(__ALLOBJS))) \
	  $(__ALLSRCS_ASM) $(__ALLSRCS_CXX)

.SECONDARY: $(_ALLSRCS) $(_ALLOBJS) Makefile $(wildcard make*)

$(CONF): $(TOPDIR)/conf/conf.auto $(TOPDIR)/include/Tw/Twautoconf.h
	cd $(TOPDIR) && ( \
	 $(BASH) scripts/Configure.tty || \
	 scripts/Configure.fallback \
	) < /dev/null > /dev/null


.modules: Makefile $(TOPDIR)/makerules $(TOPDIR)/makeosvalues $(CONF)
	@$(ECHO) $(ECHO_N) "Building .modules... $(ECHO_C)" ; \
	 $(ECHO) " $(_ALLFLAGS)" > $@ ; \
	 $(ECHO) " $(foreach B,$(BINS) $(MODBINS),$(B): .$(B).link\n .$(B).link: $(OBJS_$(B))\n)" >> $@ ; \
	 $(ECHO) " $(foreach B,$(ARLIBS),$(B): .$(B).arlib\n .$(B).arlib: $(OBJS_$(B))\n)" >> $@ ; \
	 $(ECHO) " $(foreach B,$(COLLECTS),$(B): .$(B).collect\n .$(B).collect: $(OBJS_$(B))\n)" >> $@ ; \
	 $(ECHO) done


#
# includes can be autogenerated from m4 macro files...
# these are a nightmare to catch and put in .depend:
# we transform m4/%.m4 file names into %.h and manually
# add them to .depend dependencies.
# 
#
M4_INCS=$(strip $(sort $(patsubst $(1)m4/%.m4,$(1)%m4.h,$(wildcard $(1)m4/*.m4))))

H_INCS=$(strip $(sort $(filter-out $(call M4_INCS,$(1)),$(wildcard $(1)*.h))))

map = $(foreach a,$(wildcard $(2)),$(call $(1),$(a)))

_H_FILES:=$(call H_INCS,)
_M4_FILES:=$(call M4_INCS,)

#
# cheat a little with what gets printed...
#
.depend: $(TOPDIR)/scripts/Mkdep Makefile $(TOPDIR)/makerules $(_ALLSRCS) $(_H_FILES) $(_M4_FILES)
	@$(ECHO) $(ECHO_N) "Building .depend... $(ECHO_C)" ; \
	 $< $(filter -I%,$(CC_FLAGS)) $(sort $(_ALLSRCS)) \
	   -C $(call M4_INCS,) \
	   +T $(call H_INCS,) > $@ ; \
   	 $(ECHO) done


_H_DIRS:=$(TOPDIR)/include/ $(TOPDIR)/include/T*/
_H_FILES:=$(call map,H_INCS,$(_H_DIRS))
_M4_FILES:=$(call map,M4_INCS,$(_H_DIRS))

$(TOPDIR)/.hdepend: $(TOPDIR)/scripts/Mkdep $(TOPDIR)/makerules $(_H_FILES) $(_M4_FILES)
	@$(ECHO) $(ECHO_N) "Building $(TOPDIR)/.hdepend... $(ECHO_C)" ; \
	 cd $(TOPDIR) && \
	 scripts/Mkdep '-P$$(TOPDIR)/' -Iinclude \
	   -C $(patsubst $(TOPDIR)/%,%,$(_M4_FILES)) \
	   +T $(patsubst $(TOPDIR)/%,%,$(_H_FILES)) > .hdepend ; \
   	 $(ECHO) done


#
# random dependencies:
#
$(TOPDIR)/include/Tw/Twtypes.h: $(TOPDIR)/include/Tw/uni_types.h

$(TOPDIR)/.hdepend: $(TOPDIR)/include/Tw/uni_types.h

$(TOPDIR)/include/Tw/datasizes.h: $(TOPDIR)/scripts/Getsizes
	$< > $@


force-remake:
	@:

ifeq ($(CONF__UNICODE),)
  ifneq ($(wildcard $(CONF)),)
    include $(CONF)
  endif
endif

ifneq ($(wildcard $(TOPDIR)/.uni_types.flags),)
  include $(TOPDIR)/.uni_types.flags
else
  PREVIOUS_CONF__UNICODE=x
endif

#
# force re-making after building include/Tw/uni_types.h,
# so that 'make' reads new .uni_types.flags
#
ifneq ($(CONF__UNICODE),$(PREVIOUS_CONF__UNICODE))
  $(TOPDIR)/include/Tw/uni_types.h: force-remake
endif

#
# this is a NO NO
#
# $(TOPDIR)/include/Tw/uni_types.h: $(CONF)
#

ifeq ($(CONF__UNICODE),n)
  $(TOPDIR)/include/Tw/uni_types.h: $(TOPDIR)/scripts/Mkunitypes16
	$< $(MAKE) > $@
	@$(ECHO) "PREVIOUS_CONF__UNICODE=$(CONF__UNICODE)" > $(TOPDIR)/.uni_types.flags
else
  $(TOPDIR)/include/Tw/uni_types.h: $(TOPDIR)/scripts/Mkunitypes32
	$< $(MAKE) > $@
	@$(ECHO) "PREVIOUS_CONF__UNICODE=$(CONF__UNICODE)" > $(TOPDIR)/.uni_types.flags
endif


$(TOPDIR)/include/Tw/Twautoconf.h: $(TOPDIR)/include/autoconf.h $(TOPDIR)/makerules
	@$(ECHO) $(ECHO_N) "Building $(TOPDIR)/include/Tw/Twautoconf.h... $(ECHO_C)" ; \
	 echo "#ifndef _TW_AUTOCONF_H" > $@ && \
	 echo "#define _TW_AUTOCONF_H" >> $@ && \
	 echo >> $@ && \
	 sed -e 's/HAVE_/TW_HAVE_/g' -e 's/RETSIGTYPE/TW_RETSIGTYPE/g' \
	  -e 's/STDC_HEADERS/TW_STDC_HEADERS/g' -e 's/SETVBUF/TW_SETVBUF/g' \
	  -e 's/TIME_WITH_SYS_TIME/TW_TIME_WITH_SYS_TIME/g' \
	  -e 's/TM_IN_SYS_TIME/TW_TM_IN_SYS_TIME/g' < $< >> $@ && \
	 echo >> $@ && \
	 echo "#endif /* _TW_AUTOCONF_H */" >> $@ ; \
	$(ECHO) done



$(TOPDIR)/scripts/Getsizes: $(TOPDIR)/scripts/getsizes.c $(TOPDIR)/include/Tw/datatypes.h $(TOPDIR)/include/autoconf.h
	$(CC) $(CC_FLAGS) $(LD_FLAGS) $< -o $@

$(TOPDIR)/scripts/Mkdep: $(TOPDIR)/scripts/mkdep.c $(TOPDIR)/include/Tw/datasizes.h $(TOPDIR)/include/autoconf.h
	$(CC) $(CC_FLAGS) $(LD_FLAGS) $< -o $@

$(TOPDIR)/scripts/Bitmap: $(TOPDIR)/scripts/bitmap.c
	$(CC) $(CC_FLAGS) $(LD_FLAGS) $< -o $@
	

#
# target to recursively build all subdirectories
#
subdirs: $(foreach D, $(SUBDIRS), dir-$(D))

dir-%:
	$(MAKE) -C $*

#
# torture is the target to compile all source files in the current directory
# under all possible configurations. VERY useful to spot bugs.
#
# Torture is just like torture, except it also recursively Tortures
# all subdirectories.
#
# They need a lot of autogenerated files, but currently have do explicit
# dependencies for them, so you should run 'make' before invoking one of these.
#

torture-%.c: %.c Makefile $(TOPDIR)/makerules $(TOPDIR)/scripts/Torture $(TOPDIR)/scripts/Bitmap
	@echo; echo "Torturing $< ..."; echo;
	$(BASH) $(TOPDIR)/scripts/Torture $(TOPDIR)/scripts/Bitmap $(CC) $(CC_FLAGS) $(CC_FLAGS_$*.o) -c $< -o $*.o -- $<

torture: $(_ALLSRCS) $(foreach S,$(_ALLSRCS),torture-$(S))
	
Torture: torture $(foreach D, $(SUBDIRS), Torture-dir-$(D))

Torture-dir-%:
	$(MAKE) Torture -C $*

#
# full-autogen is the target to build all autogenerated files that require
# extra tools (m4, bison, flex ...) and thus must be already present
# when releasing twin, to let people build with just compiler and GNU make.
# In order to run './configure', also sed and grep are required.
# 'make config', 'make menuconfig', 'make gconfig' and 'make Torture'
# require GNU bash too.
#
autogen post-autogen: do-autogen

do-autogen: pre-autogen $(foreach D, $(SUBDIRS), autogen-dir-$(D))

autogen-dir-%:
	$(MAKE) autogen -C $*

pre-autogen:


install: $(foreach D, $(SUBDIRS), install-dir-$(D))

install-dir-%:
	$(MAKE) install -C $* DESTDIR=$(DESTDIR)

clean: $(foreach D, $(SUBDIRS), clean-dir-$(D))

clean-dir-%:
	$(MAKE) clean -C $*

%m4.h: m4/%.m4 $(wildcard m4/m4_*.m4 $(TOPDIR)/include/m4/*.m4h)
	$(M4) -I$(TOPDIR)/include $< > $@

%_u.c: %.c
	$(LN) $(notdir $<) $@

%.o: %.c
	$(CC) $(sort $(CC_FLAGS) $(CC_FLAGS_$@)) -c $< -o $@
	@$(ECHO) ' ifeq ($$(CC) $$(sort $$(CC_FLAGS) $$(CC_FLAGS_$@)),$(CC) $(sort $(CC_FLAGS) $(CC_FLAGS_$@)))\n'\
	'  FILES_UP_TO_DATE += $@\n'\
	'endif' > .$@.flags

%.o: %.S
	$(CC) $(sort $(CC_FLAGS) $(CC_FLAGS_$@)) -c $< -o $@
	@$(ECHO) ' ifeq ($$(CC) $$(sort $$(CC_FLAGS) $$(CC_FLAGS_$@)),$(CC) $(sort $(CC_FLAGS) $(CC_FLAGS_$@)))\n'\
	'  FILES_UP_TO_DATE += $@\n'\
	'endif' > .$@.flags

%.o: %.C
	$(CXX) $(sort $(CC_FLAGS) $(CXX_FLAGS) $(CC_FLAGS_$@) $(CXX_FLAGS_$@)) -c $< -o $@
	@$(ECHO) ' ifeq ($(CXX) $$(sort $(CC_FLAGS) $(CXX_FLAGS) $(CC_FLAGS_$@) $(CXX_FLAGS_$@)),$(CXX) $(sort $(CC_FLAGS) $(CXX_FLAGS) $(CC_FLAGS_$@) $(CXX_FLAGS_$@)))\n'\
	'  FILES_UP_TO_DATE += $@\n'\
	'endif' > .$@.flags


#
# function to extract actual .o files from a .lst collection:
#
collect-lst=$(strip $(filter-out %.lst,$(1)) $(foreach L,$(filter %.lst,$(1)),$(call cat-lst,$(L))))
cat-lst=$(foreach F,$(shell cat $(1)),$(patsubst %,$(dir $(1))%,$(F)))
#cat-lst=$(shell echo $(1)> /dev/tty)

#
# this is the rule to link a binary. It should look like:
# % : $(OBJS_%)
#	$(CC) -o $* $(OBJS_$*) $(LD_FLAGS) $(LD_FLAGS_$*)
#	...
# but 1) nasty match-all rules like this are a real pain
# and 2) $(OBJS_%) doesn't expand
# so we put into .modules an explicited version of what follows:
# % : .%.link
# .%.link : $(OBJS_%)
#
# and we use patterns for the last step:
#       
.%.link: $(TOPDIR)/makerules
	$(CC) -o $* $(call collect-lst,$(OBJS_$*)) $(LD_FLAGS) $(LD_FLAGS_$*)
	@$(LN) $* $@ ; \
	$(ECHO) ' ifeq ($$(strip $$(CC) $$(OBJS_$*) $$(LD_FLAGS) $$(LD_FLAGS_$*)),$(strip $(CC) $(OBJS_$*) $(LD_FLAGS) $(LD_FLAGS_$*)))\n'\
	'  FILES_UP_TO_DATE += $@\n'\
	'endif' > $@.flags

#
# same with `ar' archives
#
ifeq ($(RANLIB),)
  RANLIB=:
endif

.%.arlib: $(TOPDIR)/makerules
	rm -f $* && $(AR) cr $* $(call collect-lst,$(OBJS_$*)) && $(RANLIB) $*
	@$(LN) $* $@ ; \
	 $(ECHO) ' ifeq ($$(strip $$(ARLIB) $$(OBJS_$*)),$(strip $(ARLIB) $(OBJS_$*)))\n'\
	 '  FILES_UP_TO_DATE += $@\n'\
	 'endif' > $@.flags

.%.collect: $(TOPDIR)/makerules
	$(ECHO) $(call collect-lst,$(OBJS_$*)) > $*
	@$(LN) $* $@ ; \
	 $(ECHO) ' ifeq ($$(strip $$(OBJS_$*)),$(strip $(OBJS_$*)))\n'\
	 '  FILES_UP_TO_DATE += $@\n'\
	 'endif' > $@.flags


# forbid GNU-make to `rm -f $(OBJS) $(MODOBJS) $(ARLIBOBJS)' after build
# .SECONDARY: $(OBJS) $(MODOBJS) $(ARLIBOBJS)


#
# Find files whose flags have changed and force recompilation.
# For safety, this works in the converse direction:
# every file is forced, except those whose flags are positively up-to-date.
#
FILES := $(OBJS) $(MODOBJS) $(ARLIBOBJS) $(COLLECTOBJS) \
	 $(patsubst %,.%.link,$(BINS) $(MODBINS)) \
	 $(patsubst %,.%.arlib,$(ARLIBS)) \
	 $(patsubst %,.%.collect,$(COLLECTS)) \

#
# to avoid useless re-making, assume files in other dirs are already up-to-date:
# `make' must already visit all directories anyway.
#
FILES_UP_TO_DATE := $(filter-out $(wildcard * .*), $(FILES))


FILES_FLAGS_EXIST := $(wildcard .*.flags)
ifneq ($(FILES_FLAGS_EXIST),)
 #
 # this appends files whose flags are positively up-to-date to FILES_UP_TO_DATE
 #
 include $(FILES_FLAGS_EXIST)
endif

FILES_CHANGED := $(strip $(filter-out $(FILES_UP_TO_DATE), $(FILES)))

#
# force remaking by using a phony target as prerequisite
#
dummy:
	@:

ifneq ($(FILES_CHANGED),)

$(FILES_CHANGED): dummy

endif

